From a2fac9bf59fa91795d3d9043ee7d0915505e1631 Mon Sep 17 00:00:00 2001
From: David Ng <dng@quicinc.com>
Date: Mon, 8 Mar 2010 14:10:07 -0800
Subject: [PATCH] adb: Fix stale USB transport entry during quick connect/disconnect

USB transport entry is created but not removed if it is connected
then disconnected during ADB connection setup phase.  This is
only applicable to Windows ADB executable.

CRs-Fixed: 224603

Change-Id: Ifa63a8f9a61d169c85ba89efb4299eabe68e37f3
---
 adb/usb_windows.c |   21 +++++++++++----------
 1 files changed, 11 insertions(+), 10 deletions(-)

diff --git a/adb/usb_windows.c b/adb/usb_windows.c
index 0951f67..6f3487a 100644
--- a/adb/usb_windows.c
+++ b/adb/usb_windows.c
@@ -102,7 +102,7 @@ int usb_write(usb_handle* handle, const void* data, int len);
 int usb_read(usb_handle *handle, void* data, int len);
 
 /// Cleans up opened usb handle
-void usb_cleanup_handle(usb_handle* handle);
+void usb_cleanup_handle(usb_handle* handle, int final_cleanup);
 
 /// Cleans up (but don't close) opened usb handle
 void usb_kick(usb_handle* handle);
@@ -247,7 +247,7 @@ usb_handle* do_usb_open(const wchar_t* interface_name) {
 
   // Something went wrong.
   errno = GetLastError();
-  usb_cleanup_handle(ret);
+  usb_cleanup_handle(ret, 1);
   free(ret);
   SetLastError(errno);
 
@@ -338,10 +338,12 @@ int usb_read(usb_handle *handle, void* data, int len) {
   return -1;
 }
 
-void usb_cleanup_handle(usb_handle* handle) {
+void usb_cleanup_handle(usb_handle* handle, int final_cleanup) {
   if (NULL != handle) {
-    if (NULL != handle->interface_name)
+    if (final_cleanup && (NULL != handle->interface_name)) {
       free(handle->interface_name);
+      handle->interface_name = NULL;
+    }
     if (NULL != handle->adb_write_pipe)
       AdbCloseHandle(handle->adb_write_pipe);
     if (NULL != handle->adb_read_pipe)
@@ -349,7 +351,6 @@ void usb_cleanup_handle(usb_handle* handle) {
     if (NULL != handle->adb_interface)
       AdbCloseHandle(handle->adb_interface);
 
-    handle->interface_name = NULL;
     handle->adb_write_pipe = NULL;
     handle->adb_read_pipe = NULL;
     handle->adb_interface = NULL;
@@ -360,7 +361,7 @@ void usb_kick(usb_handle* handle) {
   if (NULL != handle) {
     adb_mutex_lock(&usb_lock);
 
-    usb_cleanup_handle(handle);
+    usb_cleanup_handle(handle, 0);
 
     adb_mutex_unlock(&usb_lock);
   } else {
@@ -386,7 +387,7 @@ int usb_close(usb_handle* handle) {
     adb_mutex_unlock(&usb_lock);
 
     // Cleanup handle
-    usb_cleanup_handle(handle);
+    usb_cleanup_handle(handle, 1);
     free(handle);
   }
 
@@ -491,16 +492,16 @@ void find_devices() {
               register_usb_transport(handle, serial_number);
             } else {
               D("register_new_device failed for %s\n", interf_name);
-              usb_cleanup_handle(handle);
+              usb_cleanup_handle(handle, 1);
               free(handle);
             }
           } else {
             D("cannot get serial number\n");
-            usb_cleanup_handle(handle);
+            usb_cleanup_handle(handle, 1);
             free(handle);
           }
         } else {
-          usb_cleanup_handle(handle);
+          usb_cleanup_handle(handle, 1);
           free(handle);
         }
       }
-- 
1.6.0.4

